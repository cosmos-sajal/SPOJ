/*
3385. Yoda Goes Palindromic !

Problem code: YODA

According to a very famous web site, which in this case we will trust, defines a palindrome as ‘a word, phrase, verse, or sentence that reads the same backward or forward’. For example, the phrase A man, a plan, a canal, Panama! is a palindrome. Actually, writing texts consisting of only palindromes is part of a literary technique called constrained writing.

Now imagine the wise Yoda, the master of all, whose proficiency putting words together in sentences is one of his well-kwnown abilities. He is now interested in enriching his long- lasting, and maybe boring, inactivity periods by ‘composing’ palindromic sentences. That is, he has plans to use only palindromic sentences for his chats. For this matter, he needs to practice. The first task in his practice plan is to count all the palindromes that can be arranged out of a collection of characters.

Today, you will be Yoda’s assistant for this first task. Your only mission is to, given a sequence of characters, determine how many palindromes can be obtained with some of the characters in the sequence; you will only take into account uppercase or lowercase letters. Put in other way, you need to determine how many permutations of a give sequence of characters are palindromes. Your solution will help definitively master Yoga.

Input

The input consists of several test cases, one per line. For each test case, the input consist of a sequence of ASCII characters.

Output

For each test case you should print in a single line, and according to the order of the test cases, the total number of palindromes generated by the input sequence of ASCII characters. For your purpose, you should only consider uppercase or lowercase characters appearing in the input; any other character should be ignored in the calculations. Uppercase and lowercase characters are not considered different; for example, A and a should not be considered different. In any case, the total number of palindromes will not exceed the number e^43 , where e is approximately 2.71828. Remember that the empty sequence is a palindrome itself.

Example

Input:
A man, a plan, a canal, Panama!
arD,R!A
B.a.C1/
12[’;. =1

Output:
15120
2
0
1

*/

#include <stdio.h>
#include <string.h>

long long int factorial[22];
long long int hash[26];

void precomputeFactorial(){
	int i;

	factorial[0] = factorial[1] = 1;
	for(i = 2 ; i <= 21 ; i++)
		factorial[i] = factorial[i - 1] * i;
}


int main(){
	char str[2000];
	int i, strlength, flag;
	long long int numerator, denominator;

	precomputeFactorial();

	while(gets(str)){
		strlength = strlen(str);
		flag = 0;
		numerator = 0;
		denominator = 1;

		if(strlength == 0){
			printf("1\n");	// when the string is empty
			continue;
		}

		for(i = 0 ; i < 26 ; i++)
			hash[i] = 0;

		for(i = 0 ; i < strlength ; i++){
			if(str[i] >= 'A' && str[i] <= 'Z'){
				flag = 1;
				hash[str[i] - 'A']++;
			}
			else if(str[i] >= 'a' && str[i] <= 'z'){
				flag = 1;
				hash[str[i] - 'a']++;
			}
		}

		if(!flag){
			printf("1\n");	// when the string doesn't contains a single alphabet, like 12[’;. =1
			continue;
		}

		flag = 0;
		strlength = 0;

		for(i = 0 ; i < 26 ; i++)
			if(hash[i] != 0)
				strlength += hash[i];

		if(strlength % 2 == 0){
			for(i = 0 ; i < 26 ; i++){
				if(hash[i] % 2 != 0){
					flag = -1;
					break;
				}
			}
		}
		else{
			for(i = 0 ; i < 26 ; i++){
				if(hash[i] % 2 != 0)
					flag++;
			}
		}

		if(flag == -1 || flag > 1){
			printf("0\n");	// when the even length string contains alphabets that occurs odd number of times and odd length string that contains more than 1 alphabet that occur odd number of times
			continue;		// in such cases palindrome is not possible
		}

		flag = 1;

		for(i = 0 ; i < 26 ; i++){
			if(hash[i] != 0){
				flag = 0;
				if(hash[i] % 2 == 0){
					numerator += hash[i] / 2;
				}
				else if(hash[i] % 2 != 0 && hash[i] > 2){
					numerator += (hash[i] - 1) / 2;
				}
			}
		}
		
		numerator = factorial[numerator];

		if(numerator == 0){
			printf("1\n");	// when the numerator is zero, this happens when the string contains a's only which are reapeating more than 42 times e.g. aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa , the number of
			continue;		// palindromes possible is 1
		}

		for(i = 0 ; i < 26 ; i++){
			if(hash[i] != 0){
				if(hash[i] % 2 == 0){
					denominator = factorial[hash[i] / 2];
					numerator /= denominator;
				}
				else if(hash[i] % 2 != 0 && hash[i] > 2){
					denominator = factorial[(hash[i] - 1) / 2];
					numerator /= denominator;
				}
			}
		}

		printf("%lld\n", numerator);

	}

	return 0;
}